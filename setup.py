from setuptools import setup, find_packages
import os
import os.path
import subprocess

classifiers = [
    "Development Status :: 2 - Pre-Alpha",
    "Intended Audience :: Developers",
    "Intended Audience :: Science/Research",
    "License :: OSI Approved :: BSD License",
    "Operating System :: OS Independent",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.6",
    "Programming Language :: Python :: 3.7",
    "Programming Language :: Python :: 3.8",
    "Topic :: Scientific/Engineering",
    "Topic :: Software Development",
]


def return_version():
    """Append annotation to version string to indicate development versions.
    An empty (modulo comments and blank lines) .oplab_pipeline_commit_hash is used
    to indicate a release, in which case nothing is appended to version
    string as defined above.
    """
    version = ""
    path_to_hashfile = os.path.join(
        os.path.dirname(__file__), ".oplab_pipeline_commit_hash"
    )
    if os.path.exists(path_to_hashfile):
        commit_version = ""
        with open(path_to_hashfile, "r") as f:
            for line in f:
                line = line.strip()
                if len(line) == 0 or line[0] == "#":
                    # Ignore blank lines and comments, the latter being
                    # any line that begins with #.
                    continue

                # First non-blank line is assumed to be the commit hash
                commit_version = line
                break

        if len(commit_version) > 0:
            version = commit_version
    else:
        version += ".dev0+unknown.commit"
    return version


def git_command(args):
    prefix = ["git"]
    return subprocess.check_output(prefix + args).decode().strip()


def git_pep440_version():
    # Is this called from Github Actions?
    if "GITHUB_REF_NAME" in os.environ:
        return os.environ["GITHUB_REF_NAME"]
    # Is Git installed?
    try:
        subprocess.call(["git", "--version"], stdout=subprocess.PIPE)
    except OSError:
        return None
    version_full = git_command(["describe", "--tags", "--dirty=.dirty"])
    version_tag = git_command(["describe", "--tags", "--abbrev=0"])
    version_tail = version_full[len(version_tag) :]  # noqa
    return version_tag + version_tail.replace("-", ".dev", 1).replace("-", "+", 1)


def run_setup():
    """Get version from git, then install."""
    # load long description from README.md
    readme_file = "README.md"
    if os.path.exists(readme_file):
        long_description = open(readme_file, encoding="utf-8", errors="ignore").read()
    else:
        print("Could not find readme file to extract long_description.")
        long_description = ""
    # If .git directory is present, create oplab_pipeline_commit_hash accordingly
    # to indicate version information
    if os.path.exists(".git"):
        # Provide commit hash or empty file to indicate release
        sha1 = git_pep440_version()
        if sha1 is None:
            sha1 = "unknown-commit"
        elif sha1 == "release":
            sha1 = ""
        commit_hash_header = (
            "# DO NOT EDIT!  "
            "This file was automatically generated by setup.py of oplab_pipeline"  # noqa
        )
        with open(".commit_hash", "w") as f:
            f.write(commit_hash_header + "\n")
            f.write(sha1 + "\n")
    uos_aruco_detector_version = return_version()

    setup(
        name="uos_aruco_detector",
        version=uos_aruco_detector_version,
        install_requires=[
            "PyYAML",
            "pandas",
            "numpy",
            "matplotlib",
            "opencv-python",
            "opencv-contrib-python",
        ],
        author="Ocean Perception - University of Southampton",
        author_email="miquel.massot-campos@soton.ac.uk",
        description="Aruco marker external localisation system using OpenCV capture",  # noqa
        long_description=long_description,
        url="https://github.com/ocean-perception/uos_aruco_detector",
        packages=find_packages(where="src"),
        package_dir={"": "src"},
        classifiers=classifiers,
        license="BSD",
        entry_points={  # Optional
            "console_scripts": [
                "uos_aruco_detector = uos_aruco_detector.aruco_localisation:main",
            ],
        },
    )


if __name__ == "__main__":
    run_setup()
